<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/jaredallard/nexe#readme">nexe (v1.1.2)</a>
</h1>
<h4>create single executables out of your [node/io].js applications</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.nexe">module nexe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.bundle">
            function <span class="apidocSignatureSpan">nexe.</span>bundle
            <span class="apidocSignatureSpan">(input, nc, options, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.compile">
            function <span class="apidocSignatureSpan">nexe.</span>compile
            <span class="apidocSignatureSpan">(options, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.embed">
            function <span class="apidocSignatureSpan">nexe.</span>embed
            <span class="apidocSignatureSpan">(resourceFiles, resourceRoot, options, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.monkeypatch">
            function <span class="apidocSignatureSpan">nexe.</span>monkeypatch
            <span class="apidocSignatureSpan">(filePath, monkeyPatched, processor, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.package">
            function <span class="apidocSignatureSpan">nexe.</span>package
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nexe.bundle">module nexe.bundle</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.bundle.bundle">
            function <span class="apidocSignatureSpan">nexe.</span>bundle
            <span class="apidocSignatureSpan">(input, nc, options, complete)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nexe.compile">module nexe.compile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.compile.compile">
            function <span class="apidocSignatureSpan">nexe.</span>compile
            <span class="apidocSignatureSpan">(options, complete)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nexe.embed">module nexe.embed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.embed.embed">
            function <span class="apidocSignatureSpan">nexe.</span>embed
            <span class="apidocSignatureSpan">(resourceFiles, resourceRoot, options, complete)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nexe.monkeypatch">module nexe.monkeypatch</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.monkeypatch.monkeypatch">
            function <span class="apidocSignatureSpan">nexe.</span>monkeypatch
            <span class="apidocSignatureSpan">(filePath, monkeyPatched, processor, complete)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.nexe.package">module nexe.package</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.package.package">
            function <span class="apidocSignatureSpan">nexe.</span>package
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nexe" id="apidoc.module.nexe">module nexe</a></h1>


    <h2>
        <a href="#apidoc.element.nexe.bundle" id="apidoc.element.nexe.bundle">
        function <span class="apidocSignatureSpan">nexe.</span>bundle
        <span class="apidocSignatureSpan">(input, nc, options, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bundle(input, nc, options, complete) {
  const bundlePath = path.join(nc, "lib", "nexe.js");
  const mapfile    = options.output+'.map';
  let ws           = fs.createWriteStream(bundlePath);


  const igv = '__filename,__dirname,_process';
  let insertGlobalVars = {},
      wantedGlobalVars = igv.split(',');

  // parse insertGlobalVars.
  Object.keys(insertGlobals.vars).forEach(function (x) {
    if (wantedGlobalVars.indexOf(x) === -1) {
      insertGlobalVars[x] = undefined;
    }
  });

  let paths = [path.join(nc, 'lib')];

  if(options.browserifyPaths) {
    paths = paths.concat(options.browserifyPaths);
  }


  _log('executing browserify via API');
  let bproc = browserify([input], {
    debug: options.debug,
    commondir: false,
    paths: paths,
    builtins: false,
    insertGlobalVars: insertGlobalVars,
    detectGlobals: true,
    browserField: false
  });

  if (options.browserifyExcludes &amp;&amp; Array.isArray(options.browserifyExcludes)) {
    for (let i = 0; i &lt; options.browserifyExcludes.length; i++) {
      let lib = options.browserifyExcludes[i];
      _log('Excluding \'%s\' from browserify bundle', lib);
      bproc.exclude(lib);
    }
  }

  // copy the excludes code for requires for now.
  if (options.browserifyRequires &amp;&amp; Array.isArray(options.browserifyRequires)) {
    for (let i = 0; i &lt; options.browserifyRequires.length; i++) {
      let lib = options.browserifyRequires[i];
      let name = lib.file || lib; // for  object format.

      _log('Force including \'%s\' in browserify bundle', name);
      bproc.require(lib);
    }
  }

  if(options.debug) {
    bproc.require(require.resolve('source-map-support'))
  }

  let bprocbun = bproc.bundle() // bundle
      .pipe(ws) // pipe to file

  // error on require errors, still can't contionue. ffs browserify
  bprocbun.on('error', function(err) {
    _log('error', '[browserify] '+err);
  });

  ws.on('error', function(err) {
    console.log(err);
    _log('error', 'Failed to save stdout to disk');
    process.exit(1);
  })

  ws.on('close', function() {
    var source = fs.readFileSync(bundlePath, 'utf8');
    source = source.replace(/[^\x00-\x7F]/g, "");

    // write the source modified to nexe.js
    fs.writeFile(bundlePath, source, 'utf8', function(err) {
      if (err) {
        _log('error', 'failed to save source');
        process.exit(1);
      }

      complete();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

if(options.debug) {
  bproc.require(require.resolve('source-map-support'))
}

let bprocbun = bproc.<span class="apidocCodeKeywordSpan">bundle</span>() // bundle
    .pipe(ws) // pipe to file

// error on require errors, still can't contionue. ffs browserify
bprocbun.on('error', function(err) {
  _log('error', '[browserify] '+err);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nexe.compile" id="apidoc.element.nexe.compile">
        function <span class="apidocSignatureSpan">nexe.</span>compile
        <span class="apidocSignatureSpan">(options, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (options, complete) {

  var nodeCompiler, nexeEntryPath;

  async.waterfall([
<span class="apidocCodeCommentSpan">    /**
     *check relevant options
     */
</span>    function checkOpts(next) {
      /* failsafe */
      if (options === undefined) {
        _log("error", "no options given to .compile()");
        process.exit()
      }

      /**
       * Have we been given a custom flag for python executable?
       **/
      if (options.python !== 'python' &amp;&amp; options.python !== "" &amp;&amp; options.python !== undefined) {
        if (isWin) {
          isPy = options.python.replace(/\//gm, "\\"); // use windows file paths, batch is sensitive.
        } else {
          isPy = options.python;
        }

        _log("set python as " + isPy);
      } else {
        isPy = "python";
      }

      // remove dots
      options.framework = options.framework.replace(/\./g, "");

      // set outter-scope framework variable.
      framework = options.framework;
      _log("framework =&gt; " + framework);

      version = options.nodeVersion; // better framework vc

      // check iojs version
      if (framework === "iojs" &amp;&amp; version === "latest") {
        _log("fetching iojs versions");
        mkdirp(options.nodeTempDir); // make temp dir, probably repetive.

        // create write stream so we have control over events
        var output = fs.createWriteStream(path.join(options.nodeTempDir,
          "iojs-versions.json"));

        request.get("https://iojs.org/dist/index.json")
          .pipe(output);

        output.on('close', function() {
          _log("done");
          var f = fs.readFileSync(path.join(options.nodeTempDir,
            "iojs-versions.json"));
          f = JSON.parse(f);
          version = f[0].version.replace("v", "");

          _log("iojs latest =&gt; " + version);

          // continue down along the async road
          next();
        });
      } else {
        next();
      }
    },

    /**
     * first download node
     */
    function downloadNode(next) {
      _downloadNode(version, options.nodeTempDir, options.nodeConfigureArgs, options.nodeMakeArgs, next);
    },

    /**
     * Embed Resources into a base64 encoded array.
     **/
    function embedResources(nc, next) {
      nodeCompiler = nc;

      _log("embedResources %s", options.resourceFiles);
      embed(options.resourceFiles, options.resourceRoot, nc, next);
    },

    /**
     * Write nexeres.js
     **/
    function writeResources(resources, next) {
      let resourcePath = path.join(nodeCompiler.dir, "lib", "nexeres.js");
      _log("resource -&gt; %s", resourcePath);

      fs.writeFile(resourcePath, resources, next);
    },

    /**
     * Bundle the application into one script
     **/
    function combineProject(next) {
      _log("bundle %s", options.input);
      bundle(options.input, nodeCompiler.dir, options, next);
    },

    /**
     * monkeypatch some files so that the nexe.js file is loaded when the app runs
     */

    function monkeyPatchNodeConfig(next) {
      _monkeyPatchNodeConfig(nodeCompiler, next);
    },

    /**
     * monkeypatch node.cc to prevent v8 and node from processing CLI flags
     */
    function monkeyPatchNodeCc(next) {
      if (options.flags) {
        _monkeyPatchMainCc(nodeCompiler, next);
      } else {
        next();
      }
    },

    function monkeyPatchv8FlagsCc(next) {
      if (options.jsFlags) {
        return _monkeyPatchv8FlagsCc(nodeCompiler, options, next);
      }

      return next();
    },

    /**
     * monkeypatch child_process.js so nexejs knows when it is a forked process
     */
    function monkeyPatchChildProc(next) {
      _monkeyPatchChildProcess(nodeCompiler, next);
    },

    /**
     * If an old compiled executable exists in the Release directory, delete it.
     * This lets us see if the build failed by checking the existence of this file later.
     */

    function cleanUpOldExecutable(next) {
      fs.unlink(nodeCompiler.releasePath, function(err) {
        if (err) {
          if (err.code === "ENOENT") {
            next();
          } else {
            throw err;
          } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Code Usage

```javascript

var nexe = require('nexe');

nexe.<span class="apidocCodeKeywordSpan">compile</span>({
	input: 'input.js', // where the input file is
	output: 'path/to/bin', // where to output the compiled binary
	nodeVersion: '5.5.0', // node version
	nodeTempDir: 'src', // where to store node source.
	nodeConfigureArgs: ['opt', 'val'], // for all your configure arg needs.
	nodeMakeArgs: ["-j", "4"], // when you want to control the make process.
	python: 'path/to/python', // for non-standard python setups. Or python 3.x forced ones.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nexe.embed" id="apidoc.element.nexe.embed">
        function <span class="apidocSignatureSpan">nexe.</span>embed
        <span class="apidocSignatureSpan">(resourceFiles, resourceRoot, options, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function embed(resourceFiles, resourceRoot, options, complete) {
  const encode = function(filePath) {
    return fs.readFileSync(filePath).toString('base64');
  }

  resourceFiles = resourceFiles || [];
  resourceRoot = resourceRoot || "";

  if (!Array.isArray(resourceFiles)) {
    throw new Error("Bad Argument: resourceFiles is not an array");
  }

  let buffer = "var embeddedFiles = {\n";
  for (let i = 0; i &lt; resourceFiles.length; ++i) {
    buffer += JSON.stringify(path.relative(resourceRoot, resourceFiles[i])) + ': "';
    buffer += encode(resourceFiles[i]) + '",\n';
  }

  buffer += "\n};\n\nmodule.exports.keys = function () { return Object.keys(embeddedFiles); }\n\nmodule.exports.get = ";
  buffer += accessor.toString();
  complete(null, buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nexe.monkeypatch" id="apidoc.element.nexe.monkeypatch">
        function <span class="apidocSignatureSpan">nexe.</span>monkeypatch
        <span class="apidocSignatureSpan">(filePath, monkeyPatched, processor, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _monkeypatch(filePath, monkeyPatched, processor, complete) {

  async.waterfall([

    function read (next) {
      fs.readFile(filePath, "utf8", next);
    },

    // TODO - need to parse gyp file - this is a bit hacker
    function monkeypatch (content, next) {

      if (monkeyPatched(content)) return complete();

      _log("monkey patch %s", filePath);
      processor(content, next);
    },

    function write (content, next) {
      fs.writeFile(filePath, content, "utf8", next);
    }
  ], complete);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nexe.package" id="apidoc.element.nexe.package">
        function <span class="apidocSignatureSpan">nexe.</span>package
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">package = function (path, options) {
  let _package; // scope

  // check if the file exists
  if (fs.existsSync(path) === false) {
    _log("warn", "no package.json found.");
  } else {
    _package = require(path);
  }

  if(!_package || !_package.nexe) {
    _log('error', 'trying to use package.json variables, but not setup to do so!');
    process.exit(1);
  }

  // replace ^$ w/ os specific extension on output
  if (isWin) {
    _package.nexe.output = _package.nexe.output.replace(/\^\$/, '.exe') // exe
  } else {
    _package.nexe.output = _package.nexe.output.replace(/\^\$/, '') // none
  }

  // construct the object
  let obj = {
    input: (_package.nexe.input || options.i),
    output: (_package.nexe.output || options.o),
    flags: (_package.nexe.runtime.ignoreFlags || (options.f || false)),
    nodeMakeArgs: (_package.nexe.runtime.nodeMakeArgs || []),
    resourceFiles: (_package.nexe.resourceFiles),
    nodeVersion: (_package.nexe.runtime.version || options.r),
    nodeConfigureArgs: (_package.nexe.runtime.nodeConfigureArgs || []),
    nodeMakeArgs: (_package.nexe.runtime.nodeMakeArgs || []),
    jsFlags: (_package.nexe.runtime['js-flags'] || options.j),
    python: (_package.nexe.python || options.p),
    debug: (_package.nexe.debug || options.d),
    nodeTempDir: (_package.nexe.temp || options.t),
    framework: (_package.nexe.runtime.framework || options.f)
  }

  // browserify options
  if(_package.nexe.browserify !== undefined) {
    obj.browserifyRequires = (_package.nexe.browserify.requires || []);
    obj.browserifyExcludes = (_package.nexe.browserify.excludes || []);
    obj.browserifyPaths    = (_package.nexe.browserify.paths    || []);
  }

  // TODO: get rid of this crappy code I wrote and make it less painful to read.
  Object.keys(_package.nexe).forEach(function(v, i) {
    if (v !== "runtime" &amp;&amp; v !== 'browserify') {
      _log("log", v + " =&gt; '" + _package.nexe[v] + "'");
    }
  });

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nexe.bundle" id="apidoc.module.nexe.bundle">module nexe.bundle</a></h1>


    <h2>
        <a href="#apidoc.element.nexe.bundle.bundle" id="apidoc.element.nexe.bundle.bundle">
        function <span class="apidocSignatureSpan">nexe.</span>bundle
        <span class="apidocSignatureSpan">(input, nc, options, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bundle(input, nc, options, complete) {
  const bundlePath = path.join(nc, "lib", "nexe.js");
  const mapfile    = options.output+'.map';
  let ws           = fs.createWriteStream(bundlePath);


  const igv = '__filename,__dirname,_process';
  let insertGlobalVars = {},
      wantedGlobalVars = igv.split(',');

  // parse insertGlobalVars.
  Object.keys(insertGlobals.vars).forEach(function (x) {
    if (wantedGlobalVars.indexOf(x) === -1) {
      insertGlobalVars[x] = undefined;
    }
  });

  let paths = [path.join(nc, 'lib')];

  if(options.browserifyPaths) {
    paths = paths.concat(options.browserifyPaths);
  }


  _log('executing browserify via API');
  let bproc = browserify([input], {
    debug: options.debug,
    commondir: false,
    paths: paths,
    builtins: false,
    insertGlobalVars: insertGlobalVars,
    detectGlobals: true,
    browserField: false
  });

  if (options.browserifyExcludes &amp;&amp; Array.isArray(options.browserifyExcludes)) {
    for (let i = 0; i &lt; options.browserifyExcludes.length; i++) {
      let lib = options.browserifyExcludes[i];
      _log('Excluding \'%s\' from browserify bundle', lib);
      bproc.exclude(lib);
    }
  }

  // copy the excludes code for requires for now.
  if (options.browserifyRequires &amp;&amp; Array.isArray(options.browserifyRequires)) {
    for (let i = 0; i &lt; options.browserifyRequires.length; i++) {
      let lib = options.browserifyRequires[i];
      let name = lib.file || lib; // for  object format.

      _log('Force including \'%s\' in browserify bundle', name);
      bproc.require(lib);
    }
  }

  if(options.debug) {
    bproc.require(require.resolve('source-map-support'))
  }

  let bprocbun = bproc.bundle() // bundle
      .pipe(ws) // pipe to file

  // error on require errors, still can't contionue. ffs browserify
  bprocbun.on('error', function(err) {
    _log('error', '[browserify] '+err);
  });

  ws.on('error', function(err) {
    console.log(err);
    _log('error', 'Failed to save stdout to disk');
    process.exit(1);
  })

  ws.on('close', function() {
    var source = fs.readFileSync(bundlePath, 'utf8');
    source = source.replace(/[^\x00-\x7F]/g, "");

    // write the source modified to nexe.js
    fs.writeFile(bundlePath, source, 'utf8', function(err) {
      if (err) {
        _log('error', 'failed to save source');
        process.exit(1);
      }

      complete();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

if(options.debug) {
  bproc.require(require.resolve('source-map-support'))
}

let bprocbun = bproc.<span class="apidocCodeKeywordSpan">bundle</span>() // bundle
    .pipe(ws) // pipe to file

// error on require errors, still can't contionue. ffs browserify
bprocbun.on('error', function(err) {
  _log('error', '[browserify] '+err);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nexe.compile" id="apidoc.module.nexe.compile">module nexe.compile</a></h1>


    <h2>
        <a href="#apidoc.element.nexe.compile.compile" id="apidoc.element.nexe.compile.compile">
        function <span class="apidocSignatureSpan">nexe.</span>compile
        <span class="apidocSignatureSpan">(options, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (options, complete) {

  var nodeCompiler, nexeEntryPath;

  async.waterfall([
<span class="apidocCodeCommentSpan">    /**
     *check relevant options
     */
</span>    function checkOpts(next) {
      /* failsafe */
      if (options === undefined) {
        _log("error", "no options given to .compile()");
        process.exit()
      }

      /**
       * Have we been given a custom flag for python executable?
       **/
      if (options.python !== 'python' &amp;&amp; options.python !== "" &amp;&amp; options.python !== undefined) {
        if (isWin) {
          isPy = options.python.replace(/\//gm, "\\"); // use windows file paths, batch is sensitive.
        } else {
          isPy = options.python;
        }

        _log("set python as " + isPy);
      } else {
        isPy = "python";
      }

      // remove dots
      options.framework = options.framework.replace(/\./g, "");

      // set outter-scope framework variable.
      framework = options.framework;
      _log("framework =&gt; " + framework);

      version = options.nodeVersion; // better framework vc

      // check iojs version
      if (framework === "iojs" &amp;&amp; version === "latest") {
        _log("fetching iojs versions");
        mkdirp(options.nodeTempDir); // make temp dir, probably repetive.

        // create write stream so we have control over events
        var output = fs.createWriteStream(path.join(options.nodeTempDir,
          "iojs-versions.json"));

        request.get("https://iojs.org/dist/index.json")
          .pipe(output);

        output.on('close', function() {
          _log("done");
          var f = fs.readFileSync(path.join(options.nodeTempDir,
            "iojs-versions.json"));
          f = JSON.parse(f);
          version = f[0].version.replace("v", "");

          _log("iojs latest =&gt; " + version);

          // continue down along the async road
          next();
        });
      } else {
        next();
      }
    },

    /**
     * first download node
     */
    function downloadNode(next) {
      _downloadNode(version, options.nodeTempDir, options.nodeConfigureArgs, options.nodeMakeArgs, next);
    },

    /**
     * Embed Resources into a base64 encoded array.
     **/
    function embedResources(nc, next) {
      nodeCompiler = nc;

      _log("embedResources %s", options.resourceFiles);
      embed(options.resourceFiles, options.resourceRoot, nc, next);
    },

    /**
     * Write nexeres.js
     **/
    function writeResources(resources, next) {
      let resourcePath = path.join(nodeCompiler.dir, "lib", "nexeres.js");
      _log("resource -&gt; %s", resourcePath);

      fs.writeFile(resourcePath, resources, next);
    },

    /**
     * Bundle the application into one script
     **/
    function combineProject(next) {
      _log("bundle %s", options.input);
      bundle(options.input, nodeCompiler.dir, options, next);
    },

    /**
     * monkeypatch some files so that the nexe.js file is loaded when the app runs
     */

    function monkeyPatchNodeConfig(next) {
      _monkeyPatchNodeConfig(nodeCompiler, next);
    },

    /**
     * monkeypatch node.cc to prevent v8 and node from processing CLI flags
     */
    function monkeyPatchNodeCc(next) {
      if (options.flags) {
        _monkeyPatchMainCc(nodeCompiler, next);
      } else {
        next();
      }
    },

    function monkeyPatchv8FlagsCc(next) {
      if (options.jsFlags) {
        return _monkeyPatchv8FlagsCc(nodeCompiler, options, next);
      }

      return next();
    },

    /**
     * monkeypatch child_process.js so nexejs knows when it is a forked process
     */
    function monkeyPatchChildProc(next) {
      _monkeyPatchChildProcess(nodeCompiler, next);
    },

    /**
     * If an old compiled executable exists in the Release directory, delete it.
     * This lets us see if the build failed by checking the existence of this file later.
     */

    function cleanUpOldExecutable(next) {
      fs.unlink(nodeCompiler.releasePath, function(err) {
        if (err) {
          if (err.code === "ENOENT") {
            next();
          } else {
            throw err;
          } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Code Usage

```javascript

var nexe = require('nexe');

nexe.<span class="apidocCodeKeywordSpan">compile</span>({
	input: 'input.js', // where the input file is
	output: 'path/to/bin', // where to output the compiled binary
	nodeVersion: '5.5.0', // node version
	nodeTempDir: 'src', // where to store node source.
	nodeConfigureArgs: ['opt', 'val'], // for all your configure arg needs.
	nodeMakeArgs: ["-j", "4"], // when you want to control the make process.
	python: 'path/to/python', // for non-standard python setups. Or python 3.x forced ones.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nexe.embed" id="apidoc.module.nexe.embed">module nexe.embed</a></h1>


    <h2>
        <a href="#apidoc.element.nexe.embed.embed" id="apidoc.element.nexe.embed.embed">
        function <span class="apidocSignatureSpan">nexe.</span>embed
        <span class="apidocSignatureSpan">(resourceFiles, resourceRoot, options, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function embed(resourceFiles, resourceRoot, options, complete) {
  const encode = function(filePath) {
    return fs.readFileSync(filePath).toString('base64');
  }

  resourceFiles = resourceFiles || [];
  resourceRoot = resourceRoot || "";

  if (!Array.isArray(resourceFiles)) {
    throw new Error("Bad Argument: resourceFiles is not an array");
  }

  let buffer = "var embeddedFiles = {\n";
  for (let i = 0; i &lt; resourceFiles.length; ++i) {
    buffer += JSON.stringify(path.relative(resourceRoot, resourceFiles[i])) + ': "';
    buffer += encode(resourceFiles[i]) + '",\n';
  }

  buffer += "\n};\n\nmodule.exports.keys = function () { return Object.keys(embeddedFiles); }\n\nmodule.exports.get = ";
  buffer += accessor.toString();
  complete(null, buffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nexe.monkeypatch" id="apidoc.module.nexe.monkeypatch">module nexe.monkeypatch</a></h1>


    <h2>
        <a href="#apidoc.element.nexe.monkeypatch.monkeypatch" id="apidoc.element.nexe.monkeypatch.monkeypatch">
        function <span class="apidocSignatureSpan">nexe.</span>monkeypatch
        <span class="apidocSignatureSpan">(filePath, monkeyPatched, processor, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _monkeypatch(filePath, monkeyPatched, processor, complete) {

  async.waterfall([

    function read (next) {
      fs.readFile(filePath, "utf8", next);
    },

    // TODO - need to parse gyp file - this is a bit hacker
    function monkeypatch (content, next) {

      if (monkeyPatched(content)) return complete();

      _log("monkey patch %s", filePath);
      processor(content, next);
    },

    function write (content, next) {
      fs.writeFile(filePath, content, "utf8", next);
    }
  ], complete);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nexe.package" id="apidoc.module.nexe.package">module nexe.package</a></h1>


    <h2>
        <a href="#apidoc.element.nexe.package.package" id="apidoc.element.nexe.package.package">
        function <span class="apidocSignatureSpan">nexe.</span>package
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">package = function (path, options) {
  let _package; // scope

  // check if the file exists
  if (fs.existsSync(path) === false) {
    _log("warn", "no package.json found.");
  } else {
    _package = require(path);
  }

  if(!_package || !_package.nexe) {
    _log('error', 'trying to use package.json variables, but not setup to do so!');
    process.exit(1);
  }

  // replace ^$ w/ os specific extension on output
  if (isWin) {
    _package.nexe.output = _package.nexe.output.replace(/\^\$/, '.exe') // exe
  } else {
    _package.nexe.output = _package.nexe.output.replace(/\^\$/, '') // none
  }

  // construct the object
  let obj = {
    input: (_package.nexe.input || options.i),
    output: (_package.nexe.output || options.o),
    flags: (_package.nexe.runtime.ignoreFlags || (options.f || false)),
    nodeMakeArgs: (_package.nexe.runtime.nodeMakeArgs || []),
    resourceFiles: (_package.nexe.resourceFiles),
    nodeVersion: (_package.nexe.runtime.version || options.r),
    nodeConfigureArgs: (_package.nexe.runtime.nodeConfigureArgs || []),
    nodeMakeArgs: (_package.nexe.runtime.nodeMakeArgs || []),
    jsFlags: (_package.nexe.runtime['js-flags'] || options.j),
    python: (_package.nexe.python || options.p),
    debug: (_package.nexe.debug || options.d),
    nodeTempDir: (_package.nexe.temp || options.t),
    framework: (_package.nexe.runtime.framework || options.f)
  }

  // browserify options
  if(_package.nexe.browserify !== undefined) {
    obj.browserifyRequires = (_package.nexe.browserify.requires || []);
    obj.browserifyExcludes = (_package.nexe.browserify.excludes || []);
    obj.browserifyPaths    = (_package.nexe.browserify.paths    || []);
  }

  // TODO: get rid of this crappy code I wrote and make it less painful to read.
  Object.keys(_package.nexe).forEach(function(v, i) {
    if (v !== "runtime" &amp;&amp; v !== 'browserify') {
      _log("log", v + " =&gt; '" + _package.nexe[v] + "'");
    }
  });

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>