<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/jaredallard/nexe#readme">nexe (v1.1.2)</a>
</h1>
<h4>create single executables out of your [node/io].js applications</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.nexe">module nexe</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.compile">
            function <span class="apidocSignatureSpan">nexe.</span>compile
            <span class="apidocSignatureSpan">(options, complete)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.nexe.package">
            function <span class="apidocSignatureSpan">nexe.</span>package
            <span class="apidocSignatureSpan">(path, options)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.nexe" id="apidoc.module.nexe">module nexe</a></h1>


    <h2>
        <a href="#apidoc.element.nexe.compile" id="apidoc.element.nexe.compile">
        function <span class="apidocSignatureSpan">nexe.</span>compile
        <span class="apidocSignatureSpan">(options, complete)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (options, complete) {

  var nodeCompiler, nexeEntryPath;

  async.waterfall([
<span class="apidocCodeCommentSpan">    /**
     *check relevant options
     */
</span>    function checkOpts(next) {
      /* failsafe */
      if (options === undefined) {
        _log("error", "no options given to .compile()");
        process.exit()
      }

      /**
       * Have we been given a custom flag for python executable?
       **/
      if (options.python !== 'python' &amp;&amp; options.python !== "" &amp;&amp; options.python !== undefined) {
        if (isWin) {
          isPy = options.python.replace(/\//gm, "\\"); // use windows file paths, batch is sensitive.
        } else {
          isPy = options.python;
        }

        _log("set python as " + isPy);
      } else {
        isPy = "python";
      }

      // remove dots
      options.framework = options.framework.replace(/\./g, "");

      // set outter-scope framework variable.
      framework = options.framework;
      _log("framework =&gt; " + framework);

      version = options.nodeVersion; // better framework vc

      // check iojs version
      if (framework === "iojs" &amp;&amp; version === "latest") {
        _log("fetching iojs versions");
        mkdirp(options.nodeTempDir); // make temp dir, probably repetive.

        // create write stream so we have control over events
        var output = fs.createWriteStream(path.join(options.nodeTempDir,
          "iojs-versions.json"));

        request.get("https://iojs.org/dist/index.json")
          .pipe(output);

        output.on('close', function() {
          _log("done");
          var f = fs.readFileSync(path.join(options.nodeTempDir,
            "iojs-versions.json"));
          f = JSON.parse(f);
          version = f[0].version.replace("v", "");

          _log("iojs latest =&gt; " + version);

          // continue down along the async road
          next();
        });
      } else {
        next();
      }
    },

    /**
     * first download node
     */
    function downloadNode(next) {
      _downloadNode(version, options.nodeTempDir, options.nodeConfigureArgs, options.nodeMakeArgs, next);
    },

    /**
     * Embed Resources into a base64 encoded array.
     **/
    function embedResources(nc, next) {
      nodeCompiler = nc;

      _log("embedResources %s", options.resourceFiles);
      embed(options.resourceFiles, options.resourceRoot, nc, next);
    },

    /**
     * Write nexeres.js
     **/
    function writeResources(resources, next) {
      let resourcePath = path.join(nodeCompiler.dir, "lib", "nexeres.js");
      _log("resource -&gt; %s", resourcePath);

      fs.writeFile(resourcePath, resources, next);
    },

    /**
     * Bundle the application into one script
     **/
    function combineProject(next) {
      _log("bundle %s", options.input);
      bundle(options.input, nodeCompiler.dir, options, next);
    },

    /**
     * monkeypatch some files so that the nexe.js file is loaded when the app runs
     */

    function monkeyPatchNodeConfig(next) {
      _monkeyPatchNodeConfig(nodeCompiler, next);
    },

    /**
     * monkeypatch node.cc to prevent v8 and node from processing CLI flags
     */
    function monkeyPatchNodeCc(next) {
      if (options.flags) {
        _monkeyPatchMainCc(nodeCompiler, next);
      } else {
        next();
      }
    },

    function monkeyPatchv8FlagsCc(next) {
      if (options.jsFlags) {
        return _monkeyPatchv8FlagsCc(nodeCompiler, options, next);
      }

      return next();
    },

    /**
     * monkeypatch child_process.js so nexejs knows when it is a forked process
     */
    function monkeyPatchChildProc(next) {
      _monkeyPatchChildProcess(nodeCompiler, next);
    },

    /**
     * If an old compiled executable exists in the Release directory, delete it.
     * This lets us see if the build failed by checking the existence of this file later.
     */

    function cleanUpOldExecutable(next) {
      fs.unlink(nodeCompiler.releasePath, function(err) {
        if (err) {
          if (err.code === "ENOENT") {
            next();
          } else {
            throw err;
          } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

### Code Usage

```javascript

var nexe = require('nexe');

nexe.<span class="apidocCodeKeywordSpan">compile</span>({
	input: 'input.js', // where the input file is
	output: 'path/to/bin', // where to output the compiled binary
	nodeVersion: '5.5.0', // node version
	nodeTempDir: 'src', // where to store node source.
	nodeConfigureArgs: ['opt', 'val'], // for all your configure arg needs.
	nodeMakeArgs: ["-j", "4"], // when you want to control the make process.
	python: 'path/to/python', // for non-standard python setups. Or python 3.x forced ones.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.nexe.package" id="apidoc.element.nexe.package">
        function <span class="apidocSignatureSpan">nexe.</span>package
        <span class="apidocSignatureSpan">(path, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">package = function (path, options) {
  let _package; // scope

  // check if the file exists
  if (fs.existsSync(path) === false) {
    _log("warn", "no package.json found.");
  } else {
    _package = require(path);
  }

  if(!_package || !_package.nexe) {
    _log('error', 'trying to use package.json variables, but not setup to do so!');
    process.exit(1);
  }

  // replace ^$ w/ os specific extension on output
  if (isWin) {
    _package.nexe.output = _package.nexe.output.replace(/\^\$/, '.exe') // exe
  } else {
    _package.nexe.output = _package.nexe.output.replace(/\^\$/, '') // none
  }

  // construct the object
  let obj = {
    input: (_package.nexe.input || options.i),
    output: (_package.nexe.output || options.o),
    flags: (_package.nexe.runtime.ignoreFlags || (options.f || false)),
    nodeMakeArgs: (_package.nexe.runtime.nodeMakeArgs || []),
    resourceFiles: (_package.nexe.resourceFiles),
    nodeVersion: (_package.nexe.runtime.version || options.r),
    nodeConfigureArgs: (_package.nexe.runtime.nodeConfigureArgs || []),
    nodeMakeArgs: (_package.nexe.runtime.nodeMakeArgs || []),
    jsFlags: (_package.nexe.runtime['js-flags'] || options.j),
    python: (_package.nexe.python || options.p),
    debug: (_package.nexe.debug || options.d),
    nodeTempDir: (_package.nexe.temp || options.t),
    framework: (_package.nexe.runtime.framework || options.f)
  }

  // browserify options
  if(_package.nexe.browserify !== undefined) {
    obj.browserifyRequires = (_package.nexe.browserify.requires || []);
    obj.browserifyExcludes = (_package.nexe.browserify.excludes || []);
    obj.browserifyPaths    = (_package.nexe.browserify.paths    || []);
  }

  // TODO: get rid of this crappy code I wrote and make it less painful to read.
  Object.keys(_package.nexe).forEach(function(v, i) {
    if (v !== "runtime" &amp;&amp; v !== 'browserify') {
      _log("log", v + " =&gt; '" + _package.nexe[v] + "'");
    }
  });

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>